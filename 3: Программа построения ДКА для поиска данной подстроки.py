import string

def pf(s): # длина наибольшего собственного префикса строки (если совпадение оборвалось на i-й позиции s, то pf(s)[i - 1] символов все еще совпадают)
    n = len(s)
    p = [0] * n

    for i in range(1, n): # если можете пошагово объяснить, как это работает, напишите комментарии сюда, пж
        j = p[i - 1]
        while j > 0 and s[i] != s[j]: # пока текущий символ не совпадает, пробуем более короткий возможный префикс
            j = p[j - 1]
        if s[i] == s[j]: # а вот если совпадает, увеличиваем префикс
            j += 1
        p[i] = j

    return p

alp = string.ascii_lowercase # в этом говне серьезно нельзя написать [a..z]? переходим на окамл

def dfa(s):
    n = len(s)
    p = pf(s)

    d = [{c: 0 for c in alp} for _ in range(n + 1)] # куда из состояния (0..n) перейти по символу c (состояние n - допускающее
    d[0][s[0]] = 1 # из 0 состояния по s[0] переходим в 1

    for i in range(1, n):
        for a in alp:
            if a == s[i]:
                d[i][a] = i + 1 # символ подходит, переходим к проверке следующего
            else:
                d[i][a] = d[p[i - 1]][a] # та самая префикс-функция. совпадение прервалось, переходим к p[i - 1] состоянию (aka символу s)
    return d

# сюда можно еще тестиков накидать
def test_pf():
    assert pf("aba") == [0, 0, 1]
    print("\033[32mPF PASSED\033[0m")

def test_single_char():
    s = "a"
    d = dfa(s)
    for c in alp:
        assert d[0][c] == (1 if c == "a" else 0)
        assert d[0][c] == (1 if c == "a" else 0)
    print("\033[32mDFA PASSED\033[0m")

test_pf()
test_single_char()
