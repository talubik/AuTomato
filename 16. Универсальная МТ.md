Универсальная МТ (U) – МТ, получающая на вход строки из 0 и 1, интерпретирующая их как “код МТ|разделитель|входное слово” (в случае ошибки интерпретации U останавливается, не допуская данную строку) и эмулирующая работу данной МТ с данным входным словом, то есть  
1. U допускает входную строку данная МТ => допускает данное входное слово  
2. U останавливается и не допускает входную строку => данная МТ останавливается и не допускает данное входное слово  
3. U не останавливается => данная МТ не останавливается на данном входном слове
Язык со словами вида “код МТ|разделитель|входное слово”, где закодированная МТ допускает данное входное слово (то есть язык, допускаемый U), называется универсальным и обозначается LU.

***Построение универсальной МТ

Будем строить U в виде МТ с тремя лентами и независимыми головками. Вся работа будет производиться в закодированном виде, как описано выше в “коде МТ”.

Лента 1 содержит входную строку, она не будет редактироваться в ходе работы.  
Лента 2 – рабочая для эмулируемой МТ. Изначально на неё переносится входное слово, считывающая головка ставится в его начало, далее оно редактируется в соответствии с ходом работы данной МТ.  
Лента 3 содержит код текущего состояния МТ. Изначально туда заносится код q0, а затем код заменяется в соответствии с изменением состояния эмулируемой МТ.

В ходе работы U считывает текущее состояние МТ q с третьей ленты, считывает текущий обозреваемый ей символ x со второй ленты, ищет соответствующий данной паре q,x элемент - функции на первой ленте. Если не находит его и q допускающее, то U переходит в допускающее состояние и останавливается, если q не допускающее, то останавливается без допуска. Если же элемент -функции все же был найден, то U меняет текущий символ на второй ленте в соответствии с найденным элементом и передвигает считывающую головку второй ленты соответствующим образом. Далее заменяет q на третьей ленте на новое состояние и продолжает цикл исполнения.

Замечания: 
1. В Хопкрофте первым шагом работы универсальной машины является проверка кода на корректность (что разделители стоят где надо и т.п.). То есть просто формат, а не какой-то глубокий анализ (формат обговаривается где-то за пределами машины, но это вроде бы очевидно)
2. По сути в начальный момент лента 3 пустая - на нее вторым действием наносится начальное состояние (0 или 00 в зависимости от допускаемости)
3. Про ленты (и нужны ли ленты, а не регистры)
	> Машина U, эффективно имитирующая M, т.е. не требующая сдвига ленточных символов, должна вначале определять число ленточных символов, используемых M. Если число символов лежит в пределах от 2k–1 до 2k – 1, то однозначно представить различные ленточные символы можно с помощью k-битового двоичного кода. Каждой клетке M можно поставить в соответствие k клеток машины U. Для того чтобы упростить имитацию, можно переписать в машине U данные переходы M и вместо описанного нами унарного кода переменной длины использовать бинарный код фиксированной длины

	Мораль  на мой взгляд такова, что в определении все множества конечны (на Хопкрофта ссылку не дам, но там тоже самое: [тык](https://en.wikipedia.org/wiki/Turing_machine#Formal_definition)) и нам может хватить какого-то ограниченного куска ленты (для Ленты 3 по крайней мере точно)